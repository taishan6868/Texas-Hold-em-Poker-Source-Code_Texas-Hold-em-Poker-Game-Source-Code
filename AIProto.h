// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.7.
// **********************************************************************

#ifndef __AIPROTO_H_
#define __AIPROTO_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "JFGameCommProto.h"


namespace ai
{
    enum Eum_Ret_Err
    {
        E_OK = 0,
        E_ERR = 1,
    };
    inline string etos(const Eum_Ret_Err & e)
    {
        switch(e)
        {
            case E_OK: return "E_OK";
            case E_ERR: return "E_ERR";
            default: return "";
        }
    }
    inline int stoe(const string & s, Eum_Ret_Err & e)
    {
        if(s == "E_OK")  { e=E_OK; return 0;}
        if(s == "E_ERR")  { e=E_ERR; return 0;}

        return -1;
    }

    struct TGetRobotReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotReq";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        TGetRobotReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            count = 0;
            sRoomID = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(count, 0);
            _os.write(sRoomID, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(count, 0, true);
            _is.read(sRoomID, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["count"] = tars::JsonOutput::writeJson(count);
            p->value["sRoomID"] = tars::JsonOutput::writeJson(sRoomID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(count,pObj->value["count"], true);
            tars::JsonInput::readJson(sRoomID,pObj->value["sRoomID"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(count,"count");
            _ds.display(sRoomID,"sRoomID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(count, true);
            _ds.displaySimple(sRoomID, false);
            return _os;
        }
    public:
        tars::Int32 count;
        std::string sRoomID;
    };
    inline bool operator==(const TGetRobotReq&l, const TGetRobotReq&r)
    {
        return l.count == r.count && l.sRoomID == r.sRoomID;
    }
    inline bool operator!=(const TGetRobotReq&l, const TGetRobotReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TGetRobotRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotRsp";
        }
        static string MD5()
        {
            return "b13357b0eebe28ae94056ad8067e89d5";
        }
        TGetRobotRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iResult = 0;
            iActuallyCount = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iResult, 0);
            _os.write(iActuallyCount, 1);
            if (vecUid.size() > 0)
            {
                _os.write(vecUid, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iResult, 0, true);
            _is.read(iActuallyCount, 1, true);
            _is.read(vecUid, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iResult"] = tars::JsonOutput::writeJson(iResult);
            p->value["iActuallyCount"] = tars::JsonOutput::writeJson(iActuallyCount);
            p->value["vecUid"] = tars::JsonOutput::writeJson(vecUid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iResult,pObj->value["iResult"], true);
            tars::JsonInput::readJson(iActuallyCount,pObj->value["iActuallyCount"], true);
            tars::JsonInput::readJson(vecUid,pObj->value["vecUid"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iResult,"iResult");
            _ds.display(iActuallyCount,"iActuallyCount");
            _ds.display(vecUid,"vecUid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iResult, true);
            _ds.displaySimple(iActuallyCount, true);
            _ds.displaySimple(vecUid, false);
            return _os;
        }
    public:
        tars::Int32 iResult;
        tars::Int32 iActuallyCount;
        vector<tars::Int64> vecUid;
    };
    inline bool operator==(const TGetRobotRsp&l, const TGetRobotRsp&r)
    {
        return l.iResult == r.iResult && l.iActuallyCount == r.iActuallyCount && l.vecUid == r.vecUid;
    }
    inline bool operator!=(const TGetRobotRsp&l, const TGetRobotRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TRetrieveRobotReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TRetrieveRobotReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        TRetrieveRobotReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sRoomID = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (sRoomID != "")
            {
                _os.write(sRoomID, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sRoomID, 0, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sRoomID"] = tars::JsonOutput::writeJson(sRoomID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sRoomID,pObj->value["sRoomID"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sRoomID,"sRoomID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sRoomID, false);
            return _os;
        }
    public:
        std::string sRoomID;
    };
    inline bool operator==(const TRetrieveRobotReq&l, const TRetrieveRobotReq&r)
    {
        return l.sRoomID == r.sRoomID;
    }
    inline bool operator!=(const TRetrieveRobotReq&l, const TRetrieveRobotReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TRetrieveRobotReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TRetrieveRobotReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TRetrieveRobotRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TRetrieveRobotRsp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        TRetrieveRobotRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iResult = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iResult, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iResult, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iResult"] = tars::JsonOutput::writeJson(iResult);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iResult,pObj->value["iResult"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iResult,"iResult");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iResult, false);
            return _os;
        }
    public:
        tars::Int32 iResult;
    };
    inline bool operator==(const TRetrieveRobotRsp&l, const TRetrieveRobotRsp&r)
    {
        return l.iResult == r.iResult;
    }
    inline bool operator!=(const TRetrieveRobotRsp&l, const TRetrieveRobotRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TRetrieveRobotRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TRetrieveRobotRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TRobotBatchInfoItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TRobotBatchInfoItem";
        }
        static string MD5()
        {
            return "50b5f1eaeb5ef9a625c9d9990451b1db";
        }
        TRobotBatchInfoItem()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iGameID = 0;
            sRoomID = "";
            iBatchID = 0;
            description = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iGameID, 0);
            _os.write(sRoomID, 1);
            _os.write(iBatchID, 2);
            _os.write(description, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iGameID, 0, true);
            _is.read(sRoomID, 1, true);
            _is.read(iBatchID, 2, true);
            _is.read(description, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iGameID"] = tars::JsonOutput::writeJson(iGameID);
            p->value["sRoomID"] = tars::JsonOutput::writeJson(sRoomID);
            p->value["iBatchID"] = tars::JsonOutput::writeJson(iBatchID);
            p->value["description"] = tars::JsonOutput::writeJson(description);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iGameID,pObj->value["iGameID"], true);
            tars::JsonInput::readJson(sRoomID,pObj->value["sRoomID"], true);
            tars::JsonInput::readJson(iBatchID,pObj->value["iBatchID"], true);
            tars::JsonInput::readJson(description,pObj->value["description"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iGameID,"iGameID");
            _ds.display(sRoomID,"sRoomID");
            _ds.display(iBatchID,"iBatchID");
            _ds.display(description,"description");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iGameID, true);
            _ds.displaySimple(sRoomID, true);
            _ds.displaySimple(iBatchID, true);
            _ds.displaySimple(description, false);
            return _os;
        }
    public:
        tars::Int32 iGameID;
        std::string sRoomID;
        tars::Int32 iBatchID;
        std::string description;
    };
    inline bool operator==(const TRobotBatchInfoItem&l, const TRobotBatchInfoItem&r)
    {
        return l.iGameID == r.iGameID && l.sRoomID == r.sRoomID && l.iBatchID == r.iBatchID && l.description == r.description;
    }
    inline bool operator!=(const TRobotBatchInfoItem&l, const TRobotBatchInfoItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TRobotBatchInfoItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TRobotBatchInfoItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TGetRobotBatchInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotBatchInfoRsp";
        }
        static string MD5()
        {
            return "43b5a030ffe2ee07d950c29a9b1259af";
        }
        TGetRobotBatchInfoRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iResult = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iResult, 0);
            _os.write(vecRobotInfo, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iResult, 0, true);
            _is.read(vecRobotInfo, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iResult"] = tars::JsonOutput::writeJson(iResult);
            p->value["vecRobotInfo"] = tars::JsonOutput::writeJson(vecRobotInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iResult,pObj->value["iResult"], true);
            tars::JsonInput::readJson(vecRobotInfo,pObj->value["vecRobotInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iResult,"iResult");
            _ds.display(vecRobotInfo,"vecRobotInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iResult, true);
            _ds.displaySimple(vecRobotInfo, false);
            return _os;
        }
    public:
        tars::Int32 iResult;
        vector<ai::TRobotBatchInfoItem> vecRobotInfo;
    };
    inline bool operator==(const TGetRobotBatchInfoRsp&l, const TGetRobotBatchInfoRsp&r)
    {
        return l.iResult == r.iResult && l.vecRobotInfo == r.vecRobotInfo;
    }
    inline bool operator!=(const TGetRobotBatchInfoRsp&l, const TGetRobotBatchInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotBatchInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotBatchInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TGetRobotInfoCountReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotInfoCountReq";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        TGetRobotInfoCountReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iBatchID = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iBatchID, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iBatchID, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iBatchID"] = tars::JsonOutput::writeJson(iBatchID);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iBatchID,pObj->value["iBatchID"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iBatchID,"iBatchID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iBatchID, false);
            return _os;
        }
    public:
        tars::Int32 iBatchID;
    };
    inline bool operator==(const TGetRobotInfoCountReq&l, const TGetRobotInfoCountReq&r)
    {
        return l.iBatchID == r.iBatchID;
    }
    inline bool operator!=(const TGetRobotInfoCountReq&l, const TGetRobotInfoCountReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotInfoCountReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotInfoCountReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TGetRobotInfoCountRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotInfoCountRsp";
        }
        static string MD5()
        {
            return "21fd9c45eb837491f8205d65748d59eb";
        }
        TGetRobotInfoCountRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iResult = 0;
            count = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iResult, 0);
            _os.write(count, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iResult, 0, true);
            _is.read(count, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iResult"] = tars::JsonOutput::writeJson(iResult);
            p->value["count"] = tars::JsonOutput::writeJson(count);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iResult,pObj->value["iResult"], true);
            tars::JsonInput::readJson(count,pObj->value["count"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iResult,"iResult");
            _ds.display(count,"count");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iResult, true);
            _ds.displaySimple(count, false);
            return _os;
        }
    public:
        tars::Int32 iResult;
        tars::Int32 count;
    };
    inline bool operator==(const TGetRobotInfoCountRsp&l, const TGetRobotInfoCountRsp&r)
    {
        return l.iResult == r.iResult && l.count == r.count;
    }
    inline bool operator!=(const TGetRobotInfoCountRsp&l, const TGetRobotInfoCountRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotInfoCountRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotInfoCountRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TGetRobotInfoReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotInfoReq";
        }
        static string MD5()
        {
            return "aea402d67a51a1314b2b40d2714a382f";
        }
        TGetRobotInfoReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iBatchID = 0;
            offset = 0;
            count = 10;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iBatchID, 0);
            _os.write(offset, 1);
            _os.write(count, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iBatchID, 0, true);
            _is.read(offset, 1, true);
            _is.read(count, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iBatchID"] = tars::JsonOutput::writeJson(iBatchID);
            p->value["offset"] = tars::JsonOutput::writeJson(offset);
            p->value["count"] = tars::JsonOutput::writeJson(count);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iBatchID,pObj->value["iBatchID"], true);
            tars::JsonInput::readJson(offset,pObj->value["offset"], true);
            tars::JsonInput::readJson(count,pObj->value["count"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iBatchID,"iBatchID");
            _ds.display(offset,"offset");
            _ds.display(count,"count");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iBatchID, true);
            _ds.displaySimple(offset, true);
            _ds.displaySimple(count, false);
            return _os;
        }
    public:
        tars::Int32 iBatchID;
        tars::Int32 offset;
        tars::Int32 count;
    };
    inline bool operator==(const TGetRobotInfoReq&l, const TGetRobotInfoReq&r)
    {
        return l.iBatchID == r.iBatchID && l.offset == r.offset && l.count == r.count;
    }
    inline bool operator!=(const TGetRobotInfoReq&l, const TGetRobotInfoReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotInfoReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotInfoReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TGetRobotInfoRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TGetRobotInfoRsp";
        }
        static string MD5()
        {
            return "eccfb423bba17e69a05dd15dcbfec4c0";
        }
        TGetRobotInfoRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iResult = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iResult, 0);
            _os.write(vecUid, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iResult, 0, true);
            _is.read(vecUid, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iResult"] = tars::JsonOutput::writeJson(iResult);
            p->value["vecUid"] = tars::JsonOutput::writeJson(vecUid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iResult,pObj->value["iResult"], true);
            tars::JsonInput::readJson(vecUid,pObj->value["vecUid"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iResult,"iResult");
            _ds.display(vecUid,"vecUid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iResult, true);
            _ds.displaySimple(vecUid, false);
            return _os;
        }
    public:
        tars::Int32 iResult;
        vector<tars::Int64> vecUid;
    };
    inline bool operator==(const TGetRobotInfoRsp&l, const TGetRobotInfoRsp&r)
    {
        return l.iResult == r.iResult && l.vecUid == r.vecUid;
    }
    inline bool operator!=(const TGetRobotInfoRsp&l, const TGetRobotInfoRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TGetRobotInfoRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TGetRobotInfoRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TPushChatReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TPushChatReq";
        }
        static string MD5()
        {
            return "4356884e1b34ff8732d733fd7a30c1ea";
        }
        TPushChatReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(vecUid, 0);
            _os.write(vecChat, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vecUid, 0, true);
            _is.read(vecChat, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["vecUid"] = tars::JsonOutput::writeJson(vecUid);
            p->value["vecChat"] = tars::JsonOutput::writeJson(vecChat);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(vecUid,pObj->value["vecUid"], true);
            tars::JsonInput::readJson(vecChat,pObj->value["vecChat"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(vecUid,"vecUid");
            _ds.display(vecChat,"vecChat");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(vecUid, true);
            _ds.displaySimple(vecChat, false);
            return _os;
        }
    public:
        vector<tars::Int64> vecUid;
        vector<JFGamecomm::TMsgReqChat> vecChat;
    };
    inline bool operator==(const TPushChatReq&l, const TPushChatReq&r)
    {
        return l.vecUid == r.vecUid && l.vecChat == r.vecChat;
    }
    inline bool operator!=(const TPushChatReq&l, const TPushChatReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TPushChatReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TPushChatReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TPushChatRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TPushChatRsp";
        }
        static string MD5()
        {
            return "7b010a6336d210a506b1eb4bf4c1e014";
        }
        TPushChatRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iResult = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iResult, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iResult, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iResult"] = tars::JsonOutput::writeJson(iResult);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iResult,pObj->value["iResult"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iResult,"iResult");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iResult, false);
            return _os;
        }
    public:
        tars::Int32 iResult;
    };
    inline bool operator==(const TPushChatRsp&l, const TPushChatRsp&r)
    {
        return l.iResult == r.iResult;
    }
    inline bool operator!=(const TPushChatRsp&l, const TPushChatRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TPushChatRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TPushChatRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TAIBrainDecideReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TAIBrainDecideReq";
        }
        static string MD5()
        {
            return "7185a4b83bc19b4009b934d4e1dd9399";
        }
        TAIBrainDecideReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            robotID = 0;
            roomaddr = "";
            sRoomID = "";
            round = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(robotID, 0);
            _os.write(handCards, 1);
            if (CommCards.size() > 0)
            {
                _os.write(CommCards, 2);
            }
            _os.write(roomaddr, 3);
            if (sRoomID != "")
            {
                _os.write(sRoomID, 4);
            }
            if (round != 0)
            {
                _os.write(round, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(robotID, 0, true);
            _is.read(handCards, 1, true);
            _is.read(CommCards, 2, false);
            _is.read(roomaddr, 3, true);
            _is.read(sRoomID, 4, false);
            _is.read(round, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["robotID"] = tars::JsonOutput::writeJson(robotID);
            p->value["handCards"] = tars::JsonOutput::writeJson(handCards);
            p->value["CommCards"] = tars::JsonOutput::writeJson(CommCards);
            p->value["roomaddr"] = tars::JsonOutput::writeJson(roomaddr);
            p->value["sRoomID"] = tars::JsonOutput::writeJson(sRoomID);
            p->value["round"] = tars::JsonOutput::writeJson(round);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(robotID,pObj->value["robotID"], true);
            tars::JsonInput::readJson(handCards,pObj->value["handCards"], true);
            tars::JsonInput::readJson(CommCards,pObj->value["CommCards"], false);
            tars::JsonInput::readJson(roomaddr,pObj->value["roomaddr"], true);
            tars::JsonInput::readJson(sRoomID,pObj->value["sRoomID"], false);
            tars::JsonInput::readJson(round,pObj->value["round"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(robotID,"robotID");
            _ds.display(handCards,"handCards");
            _ds.display(CommCards,"CommCards");
            _ds.display(roomaddr,"roomaddr");
            _ds.display(sRoomID,"sRoomID");
            _ds.display(round,"round");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(robotID, true);
            _ds.displaySimple(handCards, true);
            _ds.displaySimple(CommCards, true);
            _ds.displaySimple(roomaddr, true);
            _ds.displaySimple(sRoomID, true);
            _ds.displaySimple(round, false);
            return _os;
        }
    public:
        tars::Int64 robotID;
        vector<tars::Int32> handCards;
        vector<tars::Int32> CommCards;
        std::string roomaddr;
        std::string sRoomID;
        tars::Int32 round;
    };
    inline bool operator==(const TAIBrainDecideReq&l, const TAIBrainDecideReq&r)
    {
        return l.robotID == r.robotID && l.handCards == r.handCards && l.CommCards == r.CommCards && l.roomaddr == r.roomaddr && l.sRoomID == r.sRoomID && l.round == r.round;
    }
    inline bool operator!=(const TAIBrainDecideReq&l, const TAIBrainDecideReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TAIBrainDecideReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TAIBrainDecideReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TAIBrainDecideRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TAIBrainDecideRsp";
        }
        static string MD5()
        {
            return "e330e3cf3ce2848019e41d812d4150ee";
        }
        TAIBrainDecideRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            robotID = 0;
            actionType = 0;
            betNum = 0;
            sRoomID = "";
            sErrMsg = "";
            actionNum = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(robotID, 0);
            _os.write(actionType, 1);
            if (betNum != 0)
            {
                _os.write(betNum, 2);
            }
            if (sRoomID != "")
            {
                _os.write(sRoomID, 3);
            }
            if (sErrMsg != "")
            {
                _os.write(sErrMsg, 4);
            }
            if (actionNum != 0)
            {
                _os.write(actionNum, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(robotID, 0, true);
            _is.read(actionType, 1, true);
            _is.read(betNum, 2, false);
            _is.read(sRoomID, 3, false);
            _is.read(sErrMsg, 4, false);
            _is.read(actionNum, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["robotID"] = tars::JsonOutput::writeJson(robotID);
            p->value["actionType"] = tars::JsonOutput::writeJson(actionType);
            p->value["betNum"] = tars::JsonOutput::writeJson(betNum);
            p->value["sRoomID"] = tars::JsonOutput::writeJson(sRoomID);
            p->value["sErrMsg"] = tars::JsonOutput::writeJson(sErrMsg);
            p->value["actionNum"] = tars::JsonOutput::writeJson(actionNum);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(robotID,pObj->value["robotID"], true);
            tars::JsonInput::readJson(actionType,pObj->value["actionType"], true);
            tars::JsonInput::readJson(betNum,pObj->value["betNum"], false);
            tars::JsonInput::readJson(sRoomID,pObj->value["sRoomID"], false);
            tars::JsonInput::readJson(sErrMsg,pObj->value["sErrMsg"], false);
            tars::JsonInput::readJson(actionNum,pObj->value["actionNum"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(robotID,"robotID");
            _ds.display(actionType,"actionType");
            _ds.display(betNum,"betNum");
            _ds.display(sRoomID,"sRoomID");
            _ds.display(sErrMsg,"sErrMsg");
            _ds.display(actionNum,"actionNum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(robotID, true);
            _ds.displaySimple(actionType, true);
            _ds.displaySimple(betNum, true);
            _ds.displaySimple(sRoomID, true);
            _ds.displaySimple(sErrMsg, true);
            _ds.displaySimple(actionNum, false);
            return _os;
        }
    public:
        tars::Int64 robotID;
        tars::Int32 actionType;
        tars::Int64 betNum;
        std::string sRoomID;
        std::string sErrMsg;
        tars::Int32 actionNum;
    };
    inline bool operator==(const TAIBrainDecideRsp&l, const TAIBrainDecideRsp&r)
    {
        return l.robotID == r.robotID && l.actionType == r.actionType && l.betNum == r.betNum && l.sRoomID == r.sRoomID && l.sErrMsg == r.sErrMsg && l.actionNum == r.actionNum;
    }
    inline bool operator!=(const TAIBrainDecideRsp&l, const TAIBrainDecideRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TAIBrainDecideRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TAIBrainDecideRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TAIMsgTransmitReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TAIMsgTransmitReq";
        }
        static string MD5()
        {
            return "21064a97574bd18a017105bd901ad8be";
        }
        TAIMsgTransmitReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
            type = 0;
            msg = "";
            roomaddr = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
            _os.write(type, 1);
            _os.write(msg, 2);
            _os.write(roomaddr, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
            _is.read(type, 1, true);
            _is.read(msg, 2, true);
            _is.read(roomaddr, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["msg"] = tars::JsonOutput::writeJson(msg);
            p->value["roomaddr"] = tars::JsonOutput::writeJson(roomaddr);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(msg,pObj->value["msg"], true);
            tars::JsonInput::readJson(roomaddr,pObj->value["roomaddr"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            _ds.display(type,"type");
            _ds.display(msg,"msg");
            _ds.display(roomaddr,"roomaddr");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(msg, true);
            _ds.displaySimple(roomaddr, false);
            return _os;
        }
    public:
        tars::Int64 uid;
        tars::Int32 type;
        std::string msg;
        std::string roomaddr;
    };
    inline bool operator==(const TAIMsgTransmitReq&l, const TAIMsgTransmitReq&r)
    {
        return l.uid == r.uid && l.type == r.type && l.msg == r.msg && l.roomaddr == r.roomaddr;
    }
    inline bool operator!=(const TAIMsgTransmitReq&l, const TAIMsgTransmitReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TAIMsgTransmitReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TAIMsgTransmitReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TAIMsgTransmitRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TAIMsgTransmitRsp";
        }
        static string MD5()
        {
            return "60ffe44f33f21e42077330b6f89ce219";
        }
        TAIMsgTransmitRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
            uid = 0;
            type = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(resultCode, 0);
            _os.write(uid, 1);
            _os.write(type, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, true);
            _is.read(uid, 1, true);
            _is.read(type, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], true);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(uid,"uid");
            _ds.display(type,"type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(type, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        tars::Int64 uid;
        tars::Int32 type;
    };
    inline bool operator==(const TAIMsgTransmitRsp&l, const TAIMsgTransmitRsp&r)
    {
        return l.resultCode == r.resultCode && l.uid == r.uid && l.type == r.type;
    }
    inline bool operator!=(const TAIMsgTransmitRsp&l, const TAIMsgTransmitRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TAIMsgTransmitRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TAIMsgTransmitRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TAIDataReportReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TAIDataReportReq";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        TAIDataReportReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(uid, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, false);
            return _os;
        }
    public:
        tars::Int64 uid;
    };
    inline bool operator==(const TAIDataReportReq&l, const TAIDataReportReq&r)
    {
        return l.uid == r.uid;
    }
    inline bool operator!=(const TAIDataReportReq&l, const TAIDataReportReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TAIDataReportReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TAIDataReportReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TAIDataReportRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TAIDataReportRsp";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        TAIDataReportRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            resultCode = 0;
            msg = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(resultCode, 0);
            _os.write(msg, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resultCode, 0, true);
            _is.read(msg, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["resultCode"] = tars::JsonOutput::writeJson(resultCode);
            p->value["msg"] = tars::JsonOutput::writeJson(msg);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(resultCode,pObj->value["resultCode"], true);
            tars::JsonInput::readJson(msg,pObj->value["msg"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(resultCode,"resultCode");
            _ds.display(msg,"msg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(resultCode, true);
            _ds.displaySimple(msg, false);
            return _os;
        }
    public:
        tars::Int32 resultCode;
        std::string msg;
    };
    inline bool operator==(const TAIDataReportRsp&l, const TAIDataReportRsp&r)
    {
        return l.resultCode == r.resultCode && l.msg == r.msg;
    }
    inline bool operator!=(const TAIDataReportRsp&l, const TAIDataReportRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TAIDataReportRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TAIDataReportRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
