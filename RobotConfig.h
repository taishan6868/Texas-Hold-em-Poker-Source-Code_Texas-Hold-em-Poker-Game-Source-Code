// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.7.
// **********************************************************************

#ifndef __ROBOTCONFIG_H_
#define __ROBOTCONFIG_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace ai
{
    enum Eum_Service_Type
    {
        E_SERVICE_TYPE_MUTUAL = 0,
        E_SERVICE_TYPE_INITIATIVE = 1,
        E_SERVICE_TYPE_PASSIVE = 2,
    };
    inline string etos(const Eum_Service_Type & e)
    {
        switch(e)
        {
            case E_SERVICE_TYPE_MUTUAL: return "E_SERVICE_TYPE_MUTUAL";
            case E_SERVICE_TYPE_INITIATIVE: return "E_SERVICE_TYPE_INITIATIVE";
            case E_SERVICE_TYPE_PASSIVE: return "E_SERVICE_TYPE_PASSIVE";
            default: return "";
        }
    }
    inline int stoe(const string & s, Eum_Service_Type & e)
    {
        if(s == "E_SERVICE_TYPE_MUTUAL")  { e=E_SERVICE_TYPE_MUTUAL; return 0;}
        if(s == "E_SERVICE_TYPE_INITIATIVE")  { e=E_SERVICE_TYPE_INITIATIVE; return 0;}
        if(s == "E_SERVICE_TYPE_PASSIVE")  { e=E_SERVICE_TYPE_PASSIVE; return 0;}

        return -1;
    }

    struct TRobotConf : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TRobotConf";
        }
        static string MD5()
        {
            return "16ad10af7c7cc69530903d13502bf2a4";
        }
        TRobotConf()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iGameID = 0;
            sRoomID = "";
            iBatchID = 0;
            iRobotCount = 0;
            iEntryTime = 0;
            iLeaveTime = 0;
            iMinCoins = 0;
            iMaxCoins = 0;
            iEntryMinInterval = 0;
            iEntryMaxInterval = 0;
            iMinRound = 0;
            iMaxRound = 0;
            iMinPlayTime = 0;
            iMaxPlayTime = 0;
            iMinWinningRatio = 0;
            iMaxWinningRatio = 0;
            description = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iGameID, 0);
            _os.write(sRoomID, 1);
            _os.write(iBatchID, 2);
            _os.write(iRobotCount, 3);
            _os.write((tars::Int32)eServiceType, 4);
            _os.write(iEntryTime, 5);
            _os.write(iLeaveTime, 6);
            _os.write(iMinCoins, 7);
            _os.write(iMaxCoins, 8);
            _os.write(iEntryMinInterval, 9);
            _os.write(iEntryMaxInterval, 10);
            _os.write(iMinRound, 11);
            _os.write(iMaxRound, 12);
            _os.write(iMinPlayTime, 13);
            _os.write(iMaxPlayTime, 14);
            _os.write(iMinWinningRatio, 15);
            _os.write(iMaxWinningRatio, 16);
            _os.write(description, 17);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iGameID, 0, true);
            _is.read(sRoomID, 1, true);
            _is.read(iBatchID, 2, true);
            _is.read(iRobotCount, 3, true);
            tars::Int32 eTemp4 = ai::E_SERVICE_TYPE_MUTUAL;
            _is.read(eTemp4, 4, true);
            eServiceType = (ai::Eum_Service_Type)eTemp4;
            _is.read(iEntryTime, 5, true);
            _is.read(iLeaveTime, 6, true);
            _is.read(iMinCoins, 7, true);
            _is.read(iMaxCoins, 8, true);
            _is.read(iEntryMinInterval, 9, true);
            _is.read(iEntryMaxInterval, 10, true);
            _is.read(iMinRound, 11, true);
            _is.read(iMaxRound, 12, true);
            _is.read(iMinPlayTime, 13, true);
            _is.read(iMaxPlayTime, 14, true);
            _is.read(iMinWinningRatio, 15, true);
            _is.read(iMaxWinningRatio, 16, true);
            _is.read(description, 17, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iGameID"] = tars::JsonOutput::writeJson(iGameID);
            p->value["sRoomID"] = tars::JsonOutput::writeJson(sRoomID);
            p->value["iBatchID"] = tars::JsonOutput::writeJson(iBatchID);
            p->value["iRobotCount"] = tars::JsonOutput::writeJson(iRobotCount);
            p->value["eServiceType"] = tars::JsonOutput::writeJson((tars::Int32)eServiceType);
            p->value["iEntryTime"] = tars::JsonOutput::writeJson(iEntryTime);
            p->value["iLeaveTime"] = tars::JsonOutput::writeJson(iLeaveTime);
            p->value["iMinCoins"] = tars::JsonOutput::writeJson(iMinCoins);
            p->value["iMaxCoins"] = tars::JsonOutput::writeJson(iMaxCoins);
            p->value["iEntryMinInterval"] = tars::JsonOutput::writeJson(iEntryMinInterval);
            p->value["iEntryMaxInterval"] = tars::JsonOutput::writeJson(iEntryMaxInterval);
            p->value["iMinRound"] = tars::JsonOutput::writeJson(iMinRound);
            p->value["iMaxRound"] = tars::JsonOutput::writeJson(iMaxRound);
            p->value["iMinPlayTime"] = tars::JsonOutput::writeJson(iMinPlayTime);
            p->value["iMaxPlayTime"] = tars::JsonOutput::writeJson(iMaxPlayTime);
            p->value["iMinWinningRatio"] = tars::JsonOutput::writeJson(iMinWinningRatio);
            p->value["iMaxWinningRatio"] = tars::JsonOutput::writeJson(iMaxWinningRatio);
            p->value["description"] = tars::JsonOutput::writeJson(description);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iGameID,pObj->value["iGameID"], true);
            tars::JsonInput::readJson(sRoomID,pObj->value["sRoomID"], true);
            tars::JsonInput::readJson(iBatchID,pObj->value["iBatchID"], true);
            tars::JsonInput::readJson(iRobotCount,pObj->value["iRobotCount"], true);
            tars::JsonInput::readJson(eServiceType,pObj->value["eServiceType"], true);
            tars::JsonInput::readJson(iEntryTime,pObj->value["iEntryTime"], true);
            tars::JsonInput::readJson(iLeaveTime,pObj->value["iLeaveTime"], true);
            tars::JsonInput::readJson(iMinCoins,pObj->value["iMinCoins"], true);
            tars::JsonInput::readJson(iMaxCoins,pObj->value["iMaxCoins"], true);
            tars::JsonInput::readJson(iEntryMinInterval,pObj->value["iEntryMinInterval"], true);
            tars::JsonInput::readJson(iEntryMaxInterval,pObj->value["iEntryMaxInterval"], true);
            tars::JsonInput::readJson(iMinRound,pObj->value["iMinRound"], true);
            tars::JsonInput::readJson(iMaxRound,pObj->value["iMaxRound"], true);
            tars::JsonInput::readJson(iMinPlayTime,pObj->value["iMinPlayTime"], true);
            tars::JsonInput::readJson(iMaxPlayTime,pObj->value["iMaxPlayTime"], true);
            tars::JsonInput::readJson(iMinWinningRatio,pObj->value["iMinWinningRatio"], true);
            tars::JsonInput::readJson(iMaxWinningRatio,pObj->value["iMaxWinningRatio"], true);
            tars::JsonInput::readJson(description,pObj->value["description"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iGameID,"iGameID");
            _ds.display(sRoomID,"sRoomID");
            _ds.display(iBatchID,"iBatchID");
            _ds.display(iRobotCount,"iRobotCount");
            _ds.display((tars::Int32)eServiceType,"eServiceType");
            _ds.display(iEntryTime,"iEntryTime");
            _ds.display(iLeaveTime,"iLeaveTime");
            _ds.display(iMinCoins,"iMinCoins");
            _ds.display(iMaxCoins,"iMaxCoins");
            _ds.display(iEntryMinInterval,"iEntryMinInterval");
            _ds.display(iEntryMaxInterval,"iEntryMaxInterval");
            _ds.display(iMinRound,"iMinRound");
            _ds.display(iMaxRound,"iMaxRound");
            _ds.display(iMinPlayTime,"iMinPlayTime");
            _ds.display(iMaxPlayTime,"iMaxPlayTime");
            _ds.display(iMinWinningRatio,"iMinWinningRatio");
            _ds.display(iMaxWinningRatio,"iMaxWinningRatio");
            _ds.display(description,"description");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iGameID, true);
            _ds.displaySimple(sRoomID, true);
            _ds.displaySimple(iBatchID, true);
            _ds.displaySimple(iRobotCount, true);
            _ds.displaySimple((tars::Int32)eServiceType, true);
            _ds.displaySimple(iEntryTime, true);
            _ds.displaySimple(iLeaveTime, true);
            _ds.displaySimple(iMinCoins, true);
            _ds.displaySimple(iMaxCoins, true);
            _ds.displaySimple(iEntryMinInterval, true);
            _ds.displaySimple(iEntryMaxInterval, true);
            _ds.displaySimple(iMinRound, true);
            _ds.displaySimple(iMaxRound, true);
            _ds.displaySimple(iMinPlayTime, true);
            _ds.displaySimple(iMaxPlayTime, true);
            _ds.displaySimple(iMinWinningRatio, true);
            _ds.displaySimple(iMaxWinningRatio, true);
            _ds.displaySimple(description, false);
            return _os;
        }
    public:
        tars::Int32 iGameID;
        std::string sRoomID;
        tars::Int32 iBatchID;
        tars::Int32 iRobotCount;
        ai::Eum_Service_Type eServiceType;
        tars::Int32 iEntryTime;
        tars::Int32 iLeaveTime;
        tars::Int64 iMinCoins;
        tars::Int64 iMaxCoins;
        tars::Int32 iEntryMinInterval;
        tars::Int32 iEntryMaxInterval;
        tars::Int32 iMinRound;
        tars::Int32 iMaxRound;
        tars::Int32 iMinPlayTime;
        tars::Int32 iMaxPlayTime;
        tars::Int32 iMinWinningRatio;
        tars::Int32 iMaxWinningRatio;
        std::string description;
    };
    inline bool operator==(const TRobotConf&l, const TRobotConf&r)
    {
        return l.iGameID == r.iGameID && l.sRoomID == r.sRoomID && l.iBatchID == r.iBatchID && l.iRobotCount == r.iRobotCount && l.eServiceType == r.eServiceType && l.iEntryTime == r.iEntryTime && l.iLeaveTime == r.iLeaveTime && l.iMinCoins == r.iMinCoins && l.iMaxCoins == r.iMaxCoins && l.iEntryMinInterval == r.iEntryMinInterval && l.iEntryMaxInterval == r.iEntryMaxInterval && l.iMinRound == r.iMinRound && l.iMaxRound == r.iMaxRound && l.iMinPlayTime == r.iMinPlayTime && l.iMaxPlayTime == r.iMaxPlayTime && l.iMinWinningRatio == r.iMinWinningRatio && l.iMaxWinningRatio == r.iMaxWinningRatio && l.description == r.description;
    }
    inline bool operator!=(const TRobotConf&l, const TRobotConf&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TRobotConf&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TRobotConf&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TRobotRechargeConfig : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ai.TRobotRechargeConfig";
        }
        static string MD5()
        {
            return "f6ef95e934ae563699fdb993e48c46fc";
        }
        TRobotRechargeConfig()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            iBatchID = 0;
            iCoinType = 0;
            iMinCoins = 0;
            iMaxCoins = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iBatchID, 0);
            _os.write(iCoinType, 1);
            _os.write(iMinCoins, 2);
            _os.write(iMaxCoins, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iBatchID, 0, true);
            _is.read(iCoinType, 1, true);
            _is.read(iMinCoins, 2, true);
            _is.read(iMaxCoins, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["iBatchID"] = tars::JsonOutput::writeJson(iBatchID);
            p->value["iCoinType"] = tars::JsonOutput::writeJson(iCoinType);
            p->value["iMinCoins"] = tars::JsonOutput::writeJson(iMinCoins);
            p->value["iMaxCoins"] = tars::JsonOutput::writeJson(iMaxCoins);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(iBatchID,pObj->value["iBatchID"], true);
            tars::JsonInput::readJson(iCoinType,pObj->value["iCoinType"], true);
            tars::JsonInput::readJson(iMinCoins,pObj->value["iMinCoins"], true);
            tars::JsonInput::readJson(iMaxCoins,pObj->value["iMaxCoins"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(iBatchID,"iBatchID");
            _ds.display(iCoinType,"iCoinType");
            _ds.display(iMinCoins,"iMinCoins");
            _ds.display(iMaxCoins,"iMaxCoins");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iBatchID, true);
            _ds.displaySimple(iCoinType, true);
            _ds.displaySimple(iMinCoins, true);
            _ds.displaySimple(iMaxCoins, false);
            return _os;
        }
    public:
        tars::Int32 iBatchID;
        tars::Int32 iCoinType;
        tars::Int64 iMinCoins;
        tars::Int64 iMaxCoins;
    };
    inline bool operator==(const TRobotRechargeConfig&l, const TRobotRechargeConfig&r)
    {
        return l.iBatchID == r.iBatchID && l.iCoinType == r.iCoinType && l.iMinCoins == r.iMinCoins && l.iMaxCoins == r.iMaxCoins;
    }
    inline bool operator!=(const TRobotRechargeConfig&l, const TRobotRechargeConfig&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TRobotRechargeConfig&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TRobotRechargeConfig&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
